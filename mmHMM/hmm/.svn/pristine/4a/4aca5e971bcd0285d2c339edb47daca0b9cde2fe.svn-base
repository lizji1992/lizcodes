/* Copyright (C) 2009 University of Southern California
 *                    Andrew D Smith
 * Author: Andrew D. Smith, Song Qiang
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#define DEBUG

#include <numeric>
#include <cmath>
#include <fstream>

#include "smithlab_utils.hpp"
#include "smithlab_os.hpp"
#include "GenomicRegion.hpp"
#include "OptionParser.hpp"
#include "ThreeStateHDHMM.hpp"
#include "Distro.hpp"
#include "false_discovery_rate.hpp"
#include "hypergeometric-test.hpp"
#include "RNG.hpp"
#include "nonparametric-test.hpp"

using std::string;
using std::vector;
using std::cout;
using std::endl;
using std::cerr;
using std::numeric_limits;
using std::max;
using std::min;
using std::pair;
using std::make_pair;

using std::ostream_iterator;
using std::ofstream;

static void
get_meth_unmeth(const GenomicRegion &cpg, size_t &meth, size_t &unmeth) 
{
    const double prob = cpg.get_score();
    const string name(cpg.get_name());
    const size_t n_reads = atoi(name.substr(name.find_first_of(":") + 1).c_str());
    meth = static_cast<size_t>(prob * n_reads);
    unmeth = n_reads - meth;
}

static void
load_cpgs(const string &cpgs_file_a, const string &cpgs_file_b,
          vector<SimpleGenomicRegion> &cpgs,
          vector<size_t> &meth_a, vector<size_t> &unmeth_a,
          vector<size_t> &meth_b, vector<size_t> &unmeth_b,
          vector<double> &diffscores, const bool VERBOSE)
{
    static const size_t pseudocount = 1;
    
    vector<GenomicRegion> cpgs_a, cpgs_b;
    if (VERBOSE)
        cerr << "Reading input file " << cpgs_file_a << " ... ";
    ReadBEDFile(cpgs_file_a, cpgs_a);
    assert(check_sorted(cpgs_a));
    if (VERBOSE)
        cerr << " Done" << endl;

    if (VERBOSE)
        cerr << "Reading input file " << cpgs_file_b << " ... ";
    ReadBEDFile(cpgs_file_b, cpgs_b);
    assert(check_sorted(cpgs_b));
    if (VERBOSE)
        cerr << " Done" << endl;

    if (VERBOSE)
        cerr << "Calculating diffscores: ";
    size_t j = 0;
    for (size_t i = 0; i < cpgs_a.size(); ++i) 
    {
        while (j < cpgs_b.size() && cpgs_b[j] < cpgs_a[i]) ++j;
      
        if (cpgs_a[i].same_chrom(cpgs_b[j]) && 
            cpgs_a[i].get_start() == cpgs_b[j].get_start()) 
        {
            size_t m_a = 0, u_a = 0;
            get_meth_unmeth(cpgs_a[i], m_a, u_a);
            size_t m_b = 0, u_b = 0;
            get_meth_unmeth(cpgs_b[j], m_b, u_b);
	
            if (m_a + u_a > 0.0 && m_b + u_b > 0.0) 
            {
                const double diffscore = 
                    HypergeometricTest::test_one_tailed(
                        m_b + pseudocount, u_b + pseudocount, 
                        m_a + pseudocount, u_a + pseudocount);

                cpgs.push_back(cpgs_a[i]);
                meth_a.push_back(m_a);
                unmeth_a.push_back(u_a);
                meth_b.push_back(m_b);
                unmeth_b.push_back(u_b);
                diffscores.push_back(diffscore);
            }
        }
    }
    if (VERBOSE)
        cerr << "Probes retained: " << diffscores.size() << endl;
}

static void
calcualte_domain_p_values_by_sign_test(
    const vector<SimpleGenomicRegion> &cpgs,
    const vector<size_t> &meth_a,
    const vector<size_t> &unmeth_a,
    const vector<size_t> &meth_b,
    const vector<size_t> &unmeth_b,
    const vector<GenomicRegion> &domains,
    vector<double> &p_values)
{
// /////
//     cerr << "check domain_sign_test: "<< "OK" << endl;
// /////
    assert(check_sorted(cpgs));
    assert(check_sorted(domains));

    size_t j = 0;
    for (size_t i = 0; i < domains.size(); ++i)
    {
        const SimpleGenomicRegion simdom(domains[i]);
        vector<double> methylation_a, methylation_b;
        double sum_a = 0.0, sum_b = 0.0;
        size_t domain_size = 0;
        
        while (j < cpgs.size() && !simdom.contains(cpgs[j])) ++j;

        while (j < cpgs.size() && simdom.contains(cpgs[j]))
        {	
            methylation_a.push_back(
                static_cast<double>(meth_a[j]) / (meth_a[j] + unmeth_a[j]));
            methylation_b.push_back(
                static_cast<double>(meth_b[j]) / (meth_b[j] + unmeth_b[j]));
            sum_a += methylation_a.back();
            sum_b += methylation_b.back();
            ++domain_size;
            ++j;
        }

        const double p_value =
            (sum_b >= sum_a)
            ? NonParametricTest::sign_test(methylation_b, methylation_a)
            : NonParametricTest::sign_test(methylation_a, methylation_b);
        assert(p_value >= 0 && p_value <= 1);
        p_values.push_back(p_value);
    }

    assert(p_values.size() == domains.size());
// /////
//     cerr << "check domain_sign_test: "<< "OK" << endl;
// /////
}

static void
score_domain_by_domain_sign_test(
    const vector<SimpleGenomicRegion> &cpgs,
    const vector<size_t> &meth_a,  const vector<size_t> &unmeth_a, 
    const vector<size_t> &meth_b,  const vector<size_t> &unmeth_b, 
    const double fdr, double fdr_cutoff, const bool VERBOSE, 
    vector<GenomicRegion> &domains)
{
    if (VERBOSE)
        cerr << "Computing FDR cutoff based on domain hypergeometric test"
             << endl;
    vector<double> p_values;
    calcualte_domain_p_values_by_sign_test(
        cpgs, meth_a, unmeth_a, meth_b, unmeth_b, domains, p_values);
    if (fdr_cutoff == numeric_limits<double>::max())
        fdr_cutoff = FDR::get_fdr_cutoff(p_values, fdr);
    if (VERBOSE)
        cerr << "cutoff = " << fdr_cutoff << endl;
    
    // filtering domains
    size_t j = 0;
    for (size_t i = 0; i < domains.size(); ++i)
        if (p_values[i] <= fdr_cutoff)
        {
            domains[i].set_name(domains[i].get_name() + ":"
                                + smithlab::toa(p_values[i]));
            domains[j] = domains[i];
            ++j;
        }
    domains.erase(domains.begin() + j, domains.end());
}

static void
calculate_random_scores_from_background(
    const vector<size_t> &meth_a,
    const vector<size_t> &unmeth_a,
    const vector<size_t> &meth_b,
    const vector<size_t> &unmeth_b,
    const size_t & cpg_num,
    const size_t & times, 
    vector<double> &random_scores) 
{
    assert(meth_a.size() == unmeth_a.size()
           && meth_a.size() == meth_b.size()
           && meth_a.size() == unmeth_b.size());
    
    vector<double> diffmeth(meth_a.size());
    for (size_t i = 0; i < meth_a.size(); ++i)
    {
        diffmeth[i] =
            static_cast<double>(meth_b[i]) / (meth_b[i] + unmeth_b[i]) 
            - static_cast<double>(meth_a[i]) / (meth_a[i] + unmeth_a[i]);
    }

    Runif rng(std::time(NULL) + getpid());
    for (size_t j = 0; j < times; ++j)
    {
        const size_t start = rng.runif(static_cast<size_t>(0),
                                       meth_a.size() - cpg_num);
        const double sum_diffmeth =
            std::accumulate(diffmeth.begin() + start,
                            diffmeth.begin() + start + cpg_num, 0.0);
        random_scores.push_back(fabs(sum_diffmeth));
    }
    
    std::sort(random_scores.begin(), random_scores.end());
}

class DomainSizeCmp: public std::binary_function<GenomicRegion, GenomicRegion, bool>
{
public:
    bool operator()(const GenomicRegion &lhs, const GenomicRegion &rhs) const
    {
        return atoi(lhs.get_name().substr(5).c_str())
            < atoi(rhs.get_name().substr(5).c_str());
    }
};

static void
score_domain_by_diff_meth_emp_p_value(
    const vector<SimpleGenomicRegion> &cpgs,
    const vector<size_t> &meth_a,  const vector<size_t> &unmeth_a, 
    const vector<size_t> &meth_b,  const vector<size_t> &unmeth_b, 
    const double fdr, double fdr_cutoff, const bool &VERBOSE,
    vector<GenomicRegion> &domains)
{
    if (VERBOSE)
        cerr << "Computing FDR cutoff ... ";

    std::sort(domains.begin(), domains.end(), DomainSizeCmp());

    vector<double> p_values(domains.size());

    size_t domain_cpg_size = 0;
    vector<double> random_scores;
    for (size_t i = 0; i < domains.size(); ++i)
    {
        const size_t sz = atoi(domains[i].get_name().substr(5).c_str());
        const double domain_score = fabs(domains[i].get_score());

        assert(domain_cpg_size <= sz);
        if (domain_cpg_size < sz)
        {
            static const size_t random_scores_size = 50000;
            domain_cpg_size = sz;
            random_scores.clear();
            calculate_random_scores_from_background(
                meth_a, unmeth_a, meth_b, unmeth_b, domain_cpg_size,
                random_scores_size, random_scores);
        }
        
        p_values[i] = FDR::get_empirical_p_value(random_scores, domain_score);
    }

    if (fdr_cutoff == numeric_limits<double>::max())
        fdr_cutoff = FDR::get_fdr_cutoff(p_values, fdr);
    if (VERBOSE)
        cerr << "cutoff = " << fdr_cutoff << endl;

    // filtering domains
    size_t j = 0;
    for (size_t i = 0; i < domains.size(); ++i)
        if (p_values[i] <= fdr_cutoff)
        {
            domains[i].set_name(domains[i].get_name() + ":"
                                + smithlab::toa(p_values[i]));
            domains[j] = domains[i];
            ++j;
        }
    domains.erase(domains.begin() + j, domains.end());
    std::sort(domains.begin(), domains.end());
}

int
main(int argc, const char **argv) 
{
    try 
    {
        string outfile;
        string infile_a, infile_b;
        string ref_dmr_file;
        
        bool diff_meth_emp_p_value = false;
        bool domain_sign_test = false;
        double fdr = 0.05;
        double fdr_cutoff = std::numeric_limits<double>::max();
        

        // run mode flags
        bool VERBOSE = false;
    
        /****************** COMMAND LINE OPTIONS ********************/
        OptionParser opt_parse(argv[0], "A program for segmenting DNA "
                               "methylation data"
                               "<cpg-BED-file>");
        opt_parse.add_opt("input-a", 'A', "Methcount input file A", 
                          OptionParser::REQUIRED, infile_a);
        opt_parse.add_opt("input-b", 'B', "Methcount input file B", 
                          OptionParser::REQUIRED, infile_b);
        opt_parse.add_opt("regions", 'R', "File of regions to be examined", 
                          OptionParser::REQUIRED, ref_dmr_file);
        opt_parse.add_opt("out", 'o', "output file (BED format)", 
                          false, outfile);
        opt_parse.add_opt("fdr", 'F', "False discovery rate (default 0.05)",
                          OptionParser::OPTIONAL, fdr); 
        opt_parse.add_opt("fdr-cutoff", '\0',
                          "P-value cutoff based on false discovery rate",
                          OptionParser::OPTIONAL, fdr_cutoff); 
        opt_parse.add_opt("diff-meth", '\0',
                          "Use the differential methylation to compute p-values",
                          OptionParser::OPTIONAL, diff_meth_emp_p_value); 
        opt_parse.add_opt("domain-sign-test", '\0',
                          "Use sign test on domains to compute p-values",
                          OptionParser::OPTIONAL, domain_sign_test); 
        opt_parse.add_opt("verbose", 'v', "print more information", 
                          OptionParser::OPTIONAL, VERBOSE);
        
        vector<string> leftover_args;
        opt_parse.parse(argc, argv, leftover_args);
        if (argc == 1 || opt_parse.help_requested()) 
        {
            cerr << opt_parse.help_message() << endl;
            return EXIT_SUCCESS;
        }
        if (opt_parse.about_requested()) 
        {
            cerr << opt_parse.about_message() << endl;
            return EXIT_SUCCESS;
        }
        if (opt_parse.option_missing()) 
        {
            cerr << opt_parse.option_missing_message() << endl;
            return EXIT_SUCCESS;
        }

        /****************** END COMMAND LINE OPTIONS *****************/
    
        /***********************************
         * STEP 1: READ IN INPUT
         */
        vector<SimpleGenomicRegion> cpgs;
        vector<double> diffscores;
        vector<size_t> meth_a, unmeth_a, meth_b, unmeth_b;
        load_cpgs(infile_a, infile_b, cpgs,
                  meth_a, unmeth_a, meth_b, unmeth_b, diffscores, VERBOSE);
        assert(check_sorted(cpgs));
        assert(cpgs.size() == meth_a.size());
        assert(cpgs.size() == unmeth_a.size());
        assert(cpgs.size() == meth_b.size());
        assert(cpgs.size() == unmeth_b.size());
        

        vector<SimpleGenomicRegion> simdomains;
        ReadBEDFile(ref_dmr_file, simdomains);
        assert(check_sorted(simdomains));

        vector<GenomicRegion> domains;
        size_t j = 0;
        for (size_t i = 0; i < simdomains.size(); ++i)
        {
            const SimpleGenomicRegion &simdom = simdomains[i];
            double diffmeth = 0.0;
            size_t domain_size = 0;
        
            while (j < cpgs.size() && !simdom.contains(cpgs[j])
                   && (cpgs[j].get_chrom() < simdom.get_chrom()
                       || cpgs[j].get_chrom() == simdom.get_chrom()
                       && cpgs[j].get_start() < simdom.get_end()))  
                   ++j;

            while (j < cpgs.size() && simdom.contains(cpgs[j]))
            {	
                diffmeth +=
                    static_cast<double>(meth_b[j]) / (meth_b[j] + unmeth_b[j])
                    - static_cast<double>(meth_a[j]) / (meth_a[j] + unmeth_a[j]);
                ++domain_size;
                ++j;
            }
            if (domain_size > 0)
            {
                domains.push_back(GenomicRegion(simdom));
                domains.back().set_score(fabs(diffmeth));
                domains.back().set_name("DMR:" + smithlab::toa(domain_size));
            }
        }
        simdomains.clear();
        
        if (domain_sign_test)
            score_domain_by_domain_sign_test(
                cpgs, meth_a, unmeth_a, meth_b, unmeth_b,
                fdr, fdr_cutoff, VERBOSE, domains);

        if (diff_meth_emp_p_value)
            score_domain_by_diff_meth_emp_p_value(
                cpgs, meth_a, unmeth_a, meth_b, unmeth_b,
                fdr, 0.01,  VERBOSE, domains);

        /***********************************
         * STEP 6: WRITE THE RESULTS
         */
        
        if (VERBOSE)
            cerr << "Writing differentially-methylated regions file: "
                 << outfile << endl;
        std::ostream *out = (outfile.empty()) ? &cout : 
            new std::ofstream(outfile.c_str());
        for (size_t i = 0; i < domains.size(); ++i) 
            *out << domains[i] << endl;
        if (out != &cout) delete out;
    }
    catch (SMITHLABException &e) 
    {
        cerr << "ERROR:\t" << e.what() << endl;
        return EXIT_FAILURE;
    }
    catch (std::bad_alloc &ba) 
    {
        cerr << "ERROR: could not allocate memory" << endl;
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}


